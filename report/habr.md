# Потенциал и особенности применения JIT-компиляции в Python
## Введение
Многим из читателей известно, что Python достаточно медленный язык.
В сравнении с C++ принято называть замедление в 
[20-30 раз](https://towardsdatascience.com/how-fast-is-c-compared-to-python-978f18f474c7). 
Объясняется это в основном тем, что Python - интерпретируемый язык программирования.

Однако, целое сообщество программистов на питоне готовы "заплатить эту цену" ради удобства синтаксиса,
быстроты написания, изящности и выразительности кода (очевидно, что код будет казаться изящным
только в представлении *человека*, но не машины).

Здесь возникает задача оптимизации, когда хочется использовать удобный синтаксис и не так сильно
проигрывать в производительности. Существует множество разных подходов к этой задаче, среди которых
стоит выделить JIT-компиляцию (Just-In-Time) и AOT-компиляцию (Ahead-Of-Time), имеющих 
свои преимущества и недостатки.

В рамках этой статьи будет рассмотрен пример создания простого JIT-компилятора для языка Python
(как ни странно, на языке Python).
Этот компилятор не претендует на роль промышленного решения (так как там уже существуют 
[свои игроки](https://numba.pydata.org/)), а скорее призван показать, с какими особенностями
реализации может столкнуться программист, при написании подобных инструментов для прикладных и 
исследовательских нужд.

## JIT-компиляция как метод оптимизации

Для понимания идеологии JIT-компиляции рассмотрим три основных метода обработки и исполнения кода.

### Компиляция до исполнения (AOT)

Самый древний подход, заключающийся в переводе программы на языке высокого уровня до машинного кода с
последующим исполнением. Отсюда и произошло выражение "Ahead Of Time" - перед моментом выполнения. 
Наглядно и достаточно алгоритм компиляции формально показан на рисунке ниже.

![AOT компиляция](images/aot_compilation.png)

Красным отмечен блок, занимающий много времени, зелёным - относительно мало.

Плюсы подхода:
* Самая высокая производительность выполнения, так как программа сразу запускается на уровне машинного кода
* Временные затраты вынесены в стадию компиляции, которой не замечает конечный пользователь

Минусы подхода:
* Под каждую новую архитектуру процессора необходимо выполнять компиляцию заново
* Код невозможно изменить во время выполнения

### Интерпретация

В рамках языка программирования высокого уровня реализуется "виртуальная машина", которая выполняет байт-код,
поступающий из обработки текста программы в режиме реального времени.

![Интерпретация](images/interpretation.png)

И интерпретация, и исполнение байт-кода занимают относительно много времени и ресурсов, поэтому оба блока 
помечены красным.

Плюсы подхода:
* Интерактивность исполнения и максимальная гибкость настройки
* Виртуальная машина ЯВУ относительно платформно-зависимая 

Минусы подхода:
* Весь процесс анализа и исполнения кода выполняется после запуска, что приводит к задержкам во времени
* Проблема безопасности исполнения кода как входных данных
* Меньшая предсказуемость по сравнению с компилируемыми решениями

### Компиляция во время исполнения (JIT)

Компиляция во время исполнения (Just-In-Time compilation) является компромиссом двух описанных выше подходов. 
При его использовании отдельные модули в целом интерпретируемой программы компилируются для ускорения их выполнения.

Термин «Just-in-time компиляция» был заимствован из производственного термина «Точно в срок» и популяризован 
Джеймсом Гослингом, использовавшим этот термин в 1993.

![JIT компиляция](images/jit_compilation.png)

Схема работы выглядит сложнее, чем интерпретация и компиляция, в чём смысл их совмещения?

Дело в том, что один зелёный блок исполнения машинного кода может быть при многократном использовании
работать эффективнее интерпретации, покрывая расходы на однократную компиляцию.

Правда, в результате возникают накладные расходы на общение языка высокого уровня с низкоуровневым блоком 
кода. Процессы этого "общения" помечены жёлтым, и при разных задачах затраты на их выполнение 
могут как быть пренебрежимо малы, так и неприемлемо велики.

Плюсы подхода:
* Лучшая производительность по сравнению с интерпретацией (а иногда и с компиляцией)
* Машинный код будет оптимизирован под конкретную машину
* Гибкость обработки компилируемого кода, возможность перекомпиляции

Минусы подхода:
* При нерациональном использовании происходит замедление до уровня интерпретируемых программ
* Накладные расходы на вызов скомпилированных модулей могут сказаться на скорости

Примером использования JIT-компиляции компиляция регулярных выражений для более быстрого поиска в тексте.

```python
import re
import timeit

text = """Он знал, что, вернувшись в пожарное депо, он, менестрель огня, взглянув в зеркало, дружески подмигнет 
своему обожженному, измазанному сажей лицу. И позже в темноте, уже засыпая, он все еще будет чувствовать на губах 
застывшую судорожную улыбку. Она никогда не покидала его лица, никогда, сколько он себя помнит."""
expr = re.compile("никогда")
print(expr.findall(text))
# >>> ['никогда', 'никогда']
print(max(timeit.repeat(lambda: re.findall("никогда", text), number=100000)))
# >>> 0.10678319999715313
print(max(timeit.repeat(lambda: expr.findall(text), number=100000)))
# >>> 0.076313300000038
```

## JIT-компиляция в языке Python

Примерами JIT-компиляторов для языка Python являются PyPy и Numba

### PyPy

Реализация интерпретатора языка Python, написанная... на языке Python.

![PyPy](images/pypy.png)

Кусающая сама себя змея на логотипе тоже отображает эту особенность.

Технология написания транслятора языка программирования на нём самом называется раскруткой компилятора (bootstrapping) 

В отличие от стандартной реализации интерпретатора питона на языке C (так называемого CPython) в PyPy имеется
встроенный JIT-компилятор, переводящий код из диалекта питона RPython (Restricted Python) в код на C, а затем в 
машинный код во время исполнения программы. В RPython используется статическая типизация для оптимизации кода.

Проект обладает рядом преимуществ по сравнению с использованием CPython в плане производительности программ. Однако, 
далеко не все модули и библиотеки питона поддерживаются в PyPy, как и не все версии Python.

### Numba

Если бы проект, который стал основой для этой статьи, имел промышленное применение, он бы был прямым конкурентом
Numba.

![Numba](images/numba.png)

Numba - JIT-компилятор для языка Python с открытым исходным кодом, использующий проект LLVM и модуль питона llvmlite

Основной областью применения модуля является ускорение вычислений в анализе данных и графике, что следует из списка
спонсоров этого проекта: Gordon and Betty Moore Foundation, Intel, AMD, NVIDIA

Разрабатывается компанией Anaconda Inc. при поддержке DARPA и сообщества на GitHub. Имеет возможность ускорения
вычислений с использованием GPU.

Применение этого JIT-компилятора будет рассмотрено далее на примерах.

## Использование GCC для задачи JIT-компиляции

*GNU Compiler Collection* (сокращённо GCC) - набор свободно распространяемых компиляторов для множества языков,
таких как C, C++, Java, Go, Objective-C, Fortran, Ada, D

Разрабатывается и поддерживается группой программистов со всего мира и курируется Фондом 
Свободного Программного Обеспечения. По количеству поддерживаемых платформ и архитектур 
процессоров является лидером среди компиляторов.

Распространяется по лицензии [GNU GPL 3](https://ru.wikipedia.org/wiki/GNU_General_Public_License#GPL_v3),
что одновременно является плюсом и минусом. 

* С одной стороны, открытый исходный код даёт возможность пользователям
искать узкие места программы и предлагать оптимизации, любой желающий может сделать свой продукт на основе gcc,
не задумываясь над авторскими отчислениями (однако, авторов gcc всё равно придётся указать)
* С другой стороны, лицензия принуждает делать продукты использующие gcc под GNU GPL тоже открытыми. Для бизнеса
это требование может быть критично, так как, открыв исходники, они теряют исключительное право знания алгоритма
работы своих программ, и, возможно, вместе с этим часть выручки. 

Именно по этой причине большие компании с большей охотой используют Clang вместе с LLVM под более проприетарной лицензией
[Apache License 2.0](https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%86%D0%B5%D0%BD%D0%B7%D0%B8%D1%8F_Apache#Apache_License_2.0)

Опустив коммерческие подробности, стоит сказать, что для учебных и исследовательских проектов, подобных этому,
нет никакой разницы при выборе между Clang и GCC.

Забегая немного вперёд, отметим, что в нашем jit-компиляторе будет выполнять компиляцию файлов на языке C++
в динамически подключаемую библиотеку (DLL - Dynamic Linked Library).

Первой стадией компиляции будет сборка объектных фалов из исходного текста программы.

```shell
g++ -O2 -c source.cpp -o object.o
```

Утилита `g++` используется для компиляции программ на языке C++ и входит в состав GCC. Не будем перечислять и описывать
[все возможные флаги](https://man7.org/linux/man-pages/man1/g++.1.html), а отметим только те, что используются:

* `-c` - отключает работу линковщика, компиляция останавливается на промежуточной стадии объектных файлов
* `source.cpp` - названия файла с исходниками, команда gcc разрешает перечисление нескольких таких файлов
* `-o filename` - название выходного файла
* `-O2` - уровень оптимизации кода, подробнее про низкоуровневые особенности оптимизации можно почитать 
[тут](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html). Так как в проекте будут компилироваться достаточно
небольшие блоки кода, время компиляции не так важно, как скорость работы собранного модуля.

Вторым и последним шагом будет сборка динамической библиотеки из объектного файла. Это операция выполняется командой:

```shell
g++ -shared object.o -o lib.dll
```

Флаг `-shared` как раз отвечает за создание динамической библиотеки `.dll` либо `.so` в зависимости от платформы 
вместо обычного бинарного файла по типу `.exe` или `.elf`

На этом участие компилятора GCC в данном проекте заканчивается. Следует отметить, что это единственная внешняя 
зависимость этого проекта.

Замечание. Для особо ярых поклонников Clang и LLVM предусмотрена дружелюбность утилит командной строки и похожесть
интерфейса. Теоретически, даже на практике в рамках этой задачи, возможно заменить `g++ -O2` на `clang -O2` без
*явных внешних* изменений.

## Аннотации типов в Python

## Модуль AST в Python

## Разные подходы к задаче обхода синтаксического дерева

## Алгоритм JIT-компиляции программ на Python

## Работа с DLL в Python

## Оценка скорости выполнения программ с JIT-компиляцией и без

## Применимость JIT-компиляции в Python

## Выводы

## Список литературы и ссылки  
https://ru.wikipedia.org/wiki/GNU_Compiler_Collection

https://ru.wikipedia.org/wiki/GNU_General_Public_License#GPL_v3

https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html

https://towardsdatascience.com/how-fast-is-c-compared-to-python-978f18f474c7

https://man7.org/linux/man-pages/man1/g++.1.html

https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%86%D0%B5%D0%BD%D0%B7%D0%B8%D1%8F_Apache#Apache_License_2.0

https://habr.com/ru/company/huawei/blog/511854/

https://habr.com/ru/company/numdes/blog/581374/

https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8_%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D0%B5%D0%BC%D0%B0%D1%8F_%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0

https://ru.wikipedia.org/wiki/PyPy

https://en.wikipedia.org/wiki/Numba

https://numba.pydata.org/
# Потенциал и особенности применения JIT-компиляции в Python
## Введение
Многим из читателей известно, что Python достаточно медленный язык.
В сравнении с C++ принято называть замедление в 20-30 раз. Объясняется это в основном тем, что Python -
интерпретируемый язык программирования.

Однако, целое сообщество программистов на питоне готовы "заплатить эту цену" ради удобства синтаксиса,
быстроты написания, изящности и выразительности кода (очевидно, что код будет казаться изящным
только в представлении *человека*, но не машины).

Здесь возникает задача оптимизации, когда хочется использовать удобный синтаксис и не так сильно
проигрывать в производительности. Существует множество разных подходов к этой задаче, среди которых
стоит выделить JIT-компиляцию (Just-In-Time) и AOT-компиляцию (Ahead-Of-Time), имеющих 
свои преимущества и недостатки.

В рамках этой статьи будет рассмотрен пример создания простого JIT-компилятора для языка Python
(как ни странно, на языке Python).
Этот компилятор не претендует на роль промышленного решения (так как там уже существуют 
[свои игроки](https://numba.pydata.org/)), а скорее призван показать, с какими особенностями
реализации может столкнуться программист, при написании подобных инструментов для прикладных и 
исследовательских нужд.

## JIT-компиляция как метод оптимизации

Для понимания идеологии JIT-компиляции рассмотрим три основных метода обработки и исполнения кода.

### Компиляция до исполнения (AOT)

Самый древний подход, заключающийся в переводе программы на языке высокого уровня до машинного кода с
последующим исполнением. Отсюда и произошло выражение "Ahead Of Time" - перед моментом выполнения. 
Наглядно и достаточно алгоритм компиляции формально показан на рисунке ниже.

![AOT компиляция](images/aot_compilation.png)

Красным отмечен блок, занимающий много времени, зелёным - относительно мало.

Плюсы подхода:
* Самая высокая производительность выполнения, так как программа сразу запускается на уровне машинного кода
* Временные затраты вынесены в стадию компиляции, которой не замечает конечный пользователь

Минусы подхода:
* Под каждую новую архитектуру процессора необходимо выполнять компиляцию заново
* Код невозможно изменить во время выполнения

### Интерпретация

В рамках языка программирования высокого уровня реализуется "виртуальная машина", которая выполняет байт-код,
поступающий из обработки текста программы в режиме реального времени.

![Интерпретация](images/interpretation.png)

И интерпретация, и исполнение байт-кода занимают относительно много времени и ресурсов, поэтому оба блока 
помечены красным.

Плюсы подхода:
* Интерактивность исполнения и максимальная гибкость настройки
* Виртуальная машина ЯВУ относительно платформно-зависимая 

Минусы подхода:
* Весь процесс анализа и исполнения кода выполняется после запуска, что приводит к задержкам во времени
* Проблема безопасности исполнения кода как входных данных
* Меньшая предсказуемость по сравнению с компилируемыми решениями

### Компиляция во время исполнения (JIT)

Компиляция во время исполнения (Just-In-Time compilation) является компромиссом двух описанных выше подходов. 
При его использовании отдельные модули в целом интерпретируемой программы компилируются для ускорения их выполнения.

Термин «Just-in-time компиляция» был заимствован из производственного термина «Точно в срок» и популяризован 
Джеймсом Гослингом, использовавшим этот термин в 1993.

![JIT компиляция](images/jit_compilation.png)

Схема работы выглядит сложнее, чем интерпретация и компиляция, в чём смысл их совмещения?

Дело в том, что один зелёный блок исполнения машинного кода может быть при многократном использовании
работать эффективнее интерпретации, покрывая расходы на однократную компиляцию.

Правда, в результате возникают накладные расходы на общение языка высокого уровня с низкоуровневым блоком 
кода. Процессы этого "общения" помечены жёлтым, и при разных задачах затраты на их выполнение 
могут как быть пренебрежимо малы, так и неприемлемо велики.

Плюсы подхода:
* Лучшая производительность по сравнению с интерпретацией (а иногда и с компиляцией)
* Машинный код будет оптимизирован под конкретную машину
* Гибкость обработки компилируемого кода, возможность перекомпиляции

Минусы подхода:
* При нерациональном использовании происходит замедление до уровня интерпретируемых программ
* Накладные расходы на вызов скомпилированных модулей могут сказаться на скорости

Примером использования JIT-компиляции компиляция регулярных выражений для более быстрого поиска в тексте.

```python
import re

text = "abcdef"
expr = re.compile("bc")
print(expr.match(text))
```

## Использование GCC для задач JIT-компиляции

## JIT-компиляция в языке Python

## Аннотации типов в Python

## Модуль AST в Python

## Разные подходы к задаче обхода синтаксического дерева

## Алгоритм JIT-компиляции программ на Python

## Работа с DLL в Python

## Оценка скорости выполнения программ с JIT-компиляцией и без

## Применимость JIT-компиляции в Python

## Выводы

## Список литературы и ссылки  

# Потенциал и особенности применения JIT-компиляции в Python

## Введение

Многим из читателей известно, что Python достаточно медленный язык. В сравнении с C++ принято называть замедление в
[20-30 раз](https://towardsdatascience.com/how-fast-is-c-compared-to-python-978f18f474c7). Объясняется это в основном
тем, что Python - интерпретируемый язык программирования.

Однако, целое сообщество программистов на питоне готовы "заплатить эту цену" ради удобства синтаксиса, быстроты
написания, изящности и выразительности кода (очевидно, что код будет казаться изящным только в представлении *человека*,
но не машины).

Здесь возникает задача оптимизации, когда хочется использовать удобный синтаксис и не так сильно проигрывать в
производительности. Существует множество разных подходов к этой задаче, среди которых стоит выделить JIT-компиляцию (
Just-In-Time) и AOT-компиляцию (Ahead-Of-Time), имеющих свои преимущества и недостатки.

В рамках этой статьи будет рассмотрен пример создания простого JIT-компилятора для языка Python
(как ни странно, на языке Python). Этот компилятор не претендует на роль промышленного решения (так как там уже
существуют
[свои игроки](https://numba.pydata.org/)), а скорее призван показать, с какими особенностями реализации может
столкнуться программист, при написании подобных инструментов для прикладных и исследовательских нужд.

[Ссылка на исходники](https://github.com/PenzaStreetGames/MetaStruct)

## JIT-компиляция как метод оптимизации

Для понимания идеологии JIT-компиляции рассмотрим три основных метода обработки и исполнения кода.

### Компиляция до исполнения (AOT)

Самый древний подход, заключающийся в переводе программы на языке высокого уровня до машинного кода с последующим
исполнением. Отсюда и произошло выражение "Ahead Of Time" - перед моментом выполнения. Наглядно и достаточно алгоритм
компиляции формально показан на рисунке ниже.

![AOT компиляция](images/aot_compilation.png)

Красным отмечен блок, занимающий много времени, зелёным - относительно мало.

Плюсы подхода:

* Самая высокая производительность выполнения, так как программа сразу запускается на уровне машинного кода
* Временные затраты вынесены в стадию компиляции, которой не замечает конечный пользователь

Минусы подхода:

* Под каждую новую архитектуру процессора необходимо выполнять компиляцию заново
* Код невозможно изменить во время выполнения

### Интерпретация

В рамках языка программирования высокого уровня реализуется "виртуальная машина", которая выполняет байт-код,
поступающий из обработки текста программы в режиме реального времени.

![Интерпретация](images/interpretation.png)

И интерпретация, и исполнение байт-кода занимают относительно много времени и ресурсов, поэтому оба блока помечены
красным.

Плюсы подхода:

* Интерактивность исполнения и максимальная гибкость настройки
* Виртуальная машина ЯВУ относительно платформно-зависимая

Минусы подхода:

* Весь процесс анализа и исполнения кода выполняется после запуска, что приводит к задержкам во времени
* Проблема безопасности исполнения кода как входных данных
* Меньшая предсказуемость по сравнению с компилируемыми решениями

### Компиляция во время исполнения (JIT)

Компиляция во время исполнения (Just-In-Time compilation) является компромиссом двух описанных выше подходов. При его
использовании отдельные модули в целом интерпретируемой программы компилируются для ускорения их выполнения.

Термин «Just-in-time компиляция» был заимствован из производственного термина «Точно в срок» и популяризован Джеймсом
Гослингом, использовавшим этот термин в 1993.

![JIT компиляция](images/jit_compilation.png)

Схема работы выглядит сложнее, чем интерпретация и компиляция, в чём смысл их совмещения?

Дело в том, что один зелёный блок исполнения машинного кода может быть при многократном использовании работать
эффективнее интерпретации, покрывая расходы на однократную компиляцию.

Правда, в результате возникают накладные расходы на общение языка высокого уровня с низкоуровневым блоком кода. Процессы
этого "общения" помечены жёлтым, и при разных задачах затраты на их выполнение могут как быть пренебрежимо малы, так и
неприемлемо велики.

Плюсы подхода:

* Лучшая производительность по сравнению с интерпретацией (а иногда и с компиляцией)
* Машинный код будет оптимизирован под конкретную машину
* Гибкость обработки компилируемого кода, возможность перекомпиляции

Минусы подхода:

* При нерациональном использовании происходит замедление до уровня интерпретируемых программ
* Накладные расходы на вызов скомпилированных модулей могут сказаться на скорости

Примером использования JIT-компиляции компиляция регулярных выражений для более быстрого поиска в тексте.

```python
import re
import timeit

text = """Он знал, что, вернувшись в пожарное депо, он, менестрель огня, взглянув в зеркало, дружески подмигнет 
своему обожженному, измазанному сажей лицу. И позже в темноте, уже засыпая, он все еще будет чувствовать на губах 
застывшую судорожную улыбку. Она никогда не покидала его лица, никогда, сколько он себя помнит."""
expr = re.compile("никогда")
print(expr.findall(text))
# >>> ['никогда', 'никогда']
print(max(timeit.repeat(lambda: re.findall("никогда", text), number=100000)))
# >>> 0.10678319999715313
print(max(timeit.repeat(lambda: expr.findall(text), number=100000)))
# >>> 0.076313300000038
```

## JIT-компиляция в языке Python

Примерами JIT-компиляторов для языка Python являются PyPy и Numba

### PyPy

Реализация интерпретатора языка Python, написанная... на языке Python.

![PyPy](images/pypy.png)

Кусающая сама себя змея на логотипе тоже отображает эту особенность.

Технология написания транслятора языка программирования на нём самом называется раскруткой компилятора (bootstrapping)

В отличие от стандартной реализации интерпретатора питона на языке C (так называемого CPython) в PyPy имеется встроенный
JIT-компилятор, переводящий код из диалекта питона RPython (Restricted Python) в код на C, а затем в машинный код во
время исполнения программы. В RPython используется статическая типизация для оптимизации кода.

Проект обладает рядом преимуществ по сравнению с использованием CPython в плане производительности программ. Однако,
далеко не все модули и библиотеки питона поддерживаются в PyPy, как и не все версии Python.

### Numba

Если бы проект, который стал основой для этой статьи, имел промышленное применение, он бы был прямым конкурентом Numba.

![Numba](images/numba.png)

Numba - JIT-компилятор для языка Python с открытым исходным кодом, использующий проект LLVM и модуль питона llvmlite

Основной областью применения модуля является ускорение вычислений в анализе данных и графике, что следует из списка
спонсоров этого проекта: Gordon and Betty Moore Foundation, Intel, AMD, NVIDIA

Разрабатывается компанией Anaconda Inc. при поддержке DARPA и сообщества на GitHub. Имеет возможность ускорения
вычислений с использованием GPU.

Применение этого JIT-компилятора будет рассмотрено далее на примерах.

## Аннотации типов в Python

Механизм, добавленный относительно недавно, с версии Python 3.6, пытающийся хоть как-то решить проблему поддержки
больших проектов, где типы переменных, разбросанных на тысячах строк кода, не так уж очевидны.

Про использование аннотаций типов есть хорошие статьи в
[официальной документации](https://docs.python.org/3/library/typing.html)
или на [Хабре](https://habr.com/ru/company/lamoda/blog/432656/), поэтому, не углубляясь в синтаксические возможности,
рассмотрим аннотирование типов для задачи JIT-компиляции.

Одной из причин медленности питона является его динамическая типизация, так как довольно много времени уходит на
определение типа переменной перед её использованием. Также, идеология "всё есть объект" раздувает примитивные типы
данных до размера остальных объектов и классов. Поэтому, одним из способов оптимизации питона является замена типов
данных по умолчанию на примитивные.

Но для использования примитивных типов нужно явно объявить их. Рассмотрим простой пример функции сложения двух целых
чисел:

```python
def sum(x: int, y: int) -> int:
    res: int = x + y
    return res
```

В этом примере явного объявления типов требуют три вещи:

1. Аргументов функции
2. Возвращаемое из функции значение
3. Локальные переменные

Однако, от одного объявления типов программа не будет работать быстрее. Более того, она стала выглядеть громоздко, а
переменные, аргументы и возвращаемое значение всё ещё могут быть не тех типов, что объявлены.

Преимуществом использования аннотаций типов является, так называемое, документирование через код. Другой разработчик
(а возможно и вы спустя несколько месяцев), взглянув на такой код, сразу поймёт что нужно подать функции на вход, чтобы
она работала как задумано.

Если подать такую программу на вход статическому анализатору кода, такому как [MyPy](http://www.mypy-lang.org/), он
выведет все возможные проблемы, связанные с неправильным обращением к данным с объявленным типом.

В задаче создаваемого JIT-компилятора аннотации типов будут помогать однозначно сопоставлять типы данных питона с типами
данных C++. В базовой реализации будет только три типа данных:

| Тип данных Python | Тип данных C++ |
|-------------------|----------------|
| bool              | bool           |
| int               | int            |
| float             | double         |

Преобразование целого числа `int` в 32-битный `int` языка С++ не является однозначным, так как в питоне используется
длинная арифметика. Такое преобразование сделано лишь из соображений совпадения названий.

А вот `float` питона преобразуется в `double` C++ вполне однозначно, потому что именно в диапазоне типа числа с
плавающей точкой двойной точностью лежат значения типа `float` в Питоне.

В коде самого компилятора также используются аннотации типов, но об этом будет сказано далее.

## Модуль AST в Python

Первым шагом работы любого транслятора является лексический, а затем синтаксический анализ программы. При лексическом
анализе текст программы разбивается на слова - лексемы, а при синтаксическом анализе эти слова связываются по смыслу в
абстрактное синтаксическое дерево (АСТ, англ. Abstract Syntax Tree - AST)

Существуют разные подходы к написанию лексических и синтаксических анализаторов. Рассмотрим некоторые из них:

* Самый примитивный: посимвольный разбор текста, объединение букв в слова, сборка из слов дерева. Этот метод наиболее
  понятен, но заставляет переписывать много шаблонного кода, совмещать правила написания языка с правилами его
  обработки.
* Использование готовых библиотек, способных генерировать трансляторы для любого предметно-ориентированного языка
  (DSL - Domain Specific Language). В качестве примера можно привести ANTLR для Java или SLY для Python. Этот подход
  является более предпочтительным по сравнению с ручным написанием транслятора, так как со своей задачей этот класс
  программ справляется лучше, а код при их использовании становится проще и понятнее.

Но если мы говорим конкретно о Питоне, то всё становится намного проще.

* Использование встроенного в язык синтаксического анализатора. В Python такой анализатор поставляется в пакете `ast`
  стандартной библиотеки.

Последним пунктом и было решено воспользоваться в этом проекте.

Чтобы превратить строку, содержащую текст программы на Питоне в синтаксическое дерево достаточно выполнить
команду `ast.parse(program_text)`:

```python
import ast

source = """
def sum(x: int, y: int) -> int:
    res: int = x + y
    return res
"""

ast_object = ast.parse(source)
```

Чтобы убедиться, что дерево было построено правильно, можно вывести его командой `ast.dump(tree)`:

```python
import ast

source = """
def sum(x: int, y: int) -> int:
    res: int = x + y
    return res
"""
ast_object = ast.parse(source)

print(ast.dump(ast_object, indent=4))
```

Вывод будет выглядеть примерно так:

```python
Module(
    body=[
        FunctionDef(
            name='sum',
            args=arguments(
                posonlyargs=[],
                args=[
                    arg(
                        arg='x',
                        annotation=Name(id='int', ctx=Load())),
                    arg(
                        arg='y',
                        annotation=Name(id='int', ctx=Load()))],
                kwonlyargs=[],
                kw_defaults=[],
                defaults=[]),
            body=[
                AnnAssign(
                    target=Name(id='res', ctx=Store()),
                    annotation=Name(id='int', ctx=Load()),
                    value=BinOp(
                        left=Name(id='x', ctx=Load()),
                        op=Add(),
                        right=Name(id='y', ctx=Load())),
                    simple=1),
                Return(
                    value=Name(id='res', ctx=Load()))],
            decorator_list=[],
            returns=Name(id='int', ctx=Load()))],
    type_ignores=[])
```

Для больших блоков кода синтаксическое дерево будет ещё больше, но так как обработка будет происходить программно, это
не играет роли.

Таким образом, проблема построения абстрактного синтаксического дерева была решена без написания хотя бы одной строчки
кода.

## Разные подходы к задаче обхода синтаксического дерева

Построив дерево, можно приступать к его обходу. В результате обхода должна получиться строка - текст программы на языке
C++. Помимо этого, необходимо при рассмотрении функций получить данные о её сигнатуре, о чём будет сказано позже. Однако
задачу обхода AST можно решать по-разному.

### Функции обхода со словарями

Будем рассматривать задачу обхода узла типа `BinOp` - бинарной операции. Согласно документации модуля, к возможным
операциям этого класса относят:

```
ast.Add
ast.Sub
ast.Mult
ast.Div
ast.FloorDiv
ast.Mod
ast.Pow
ast.LShift
ast.RShift
ast.BitOr
ast.BitXor
ast.BitAnd
ast.MatMult
```

Матричное умножение рассматриваться не будет, потому что этот оператор не имеет тривиальной реализации в C++.

Напишем функцию, которая будет выводить строку по шаблону:

`({левый операнд} {знак операции} {правый операнд})`

Круглые скобки используются для расстановки приоритетов операций и возможно, в некоторых местах программы они будут
излишними.

Внутри функции для выбора поддерживаемой операции буем использовать словарь:

```python
import ast


def dump_bin_op(module: ast.BinOp) -> str:
    res = ""
    left = dump_expr(module.left)
    right = dump_expr(module.right)
    op = module.op
    bin_op_signs = {
        ast.Add: "+",
        ast.Sub: "-",
        ast.Div: "/",
        ast.FloorDiv: "/",
        ast.Mult: "*",
        ast.Mod: "%",
        ast.LShift: "<<",
        ast.BitAnd: "&",
        ast.RShift: ">>",
        ast.BitOr: "|",
        ast.BitXor: "^"
    }
    op_sign = bin_op_signs[type(op)]
    return f"({left} {op_sign} {right})"
```

Функция `dump_expr` объявлена в другом месте программы и обрабатывает выражение.

В словаре `bin_op_signs` явно перечислены обрабатываемые бинарные операции и знаки, которые им соответствуют.

Преимущества такого подхода:

* Использование класса оператора как идентификатора позволяет отказаться от большого блока `if-elif-elif-...-else`
* Если в функцию попадёт неожиданный аргумент, автоматически вызовется `KeyError`

Недостатки подхода:

* Явное обращение к типу объекта с помощью функции `type()`
* Вручную выполняется довольно большая работа по определению типа дочернего узла
* Названия функций обработки необходимо задавать вручную

Стоит отметить, что функции используют аннотации типов, чтобы гарантировать, что на выходе у функции будет строка, а
аргумент является экземпляром класса BinOp.

### Модификация с оператором match/case

Относительно недавно, с версии Python 3.10, стало возможно сравнение по шаблону оператором `match/case`. Людям,
пришедшим в Питон из других языков, может показаться, что это обычный аналог `switch/case`. Однако его функционал шире.

Например, можно отловить ситуацию, когда объект является экземпляром класса ast.Constant со значением аргумента
`value=True`

```python
from ast import Constant

def visit_Constant(self, node: Constant) -> str:
    match node:
        case Constant(value=True):
            return "true"
        case Constant(value=False):
            return "false"
        case _:
            return str(node.value)
```

В данном примере константа "занижает" регистр, если значение равно `True` или `False`. При этом не нужно писать 
конструкции типа `if node.value == True:` - Питон делает это за нас по виду шаблона.

`case _:` является аналогом `default:` внутри блока `switch` и задаёт поведение по умолчанию.

Подробнее про возможности оператора `match/case` можно узнать 
[тут](https://docs-python.ru/tutorial/tsikly-upravlenie-vetvleniem-python/konstruktsija-match-case/)

Перепишем функцию из прошлого раздела с применением `match/case`:

```python
import ast

def dump_bin_op(module: ast.BinOp) -> str:
    match module:
        case ast.BinOp(op=ast.Add()):
            op_sign = "+"
        case ast.BinOp(op=ast.Sub()):
            op_sign = "-"
        case ast.BinOp(op=ast.Div()):
            op_sign = "/"
        case ast.BinOp(op=ast.FloorDiv()):
            op_sign = "/"
        case ast.BinOp(op=ast.Mult()):
            op_sign = "*"
        case ast.BinOp(op=ast.Mod()):
            op_sign = "%"
        case ast.BinOp(op=ast.LShift()):
            op_sign = "<<"
        case ast.BinOp(op=ast.RShift()):
            op_sign = ">>"
        case ast.BinOp(op=ast.BitAnd()):
            op_sign = "&"
        case ast.BinOp(op=ast.BitOr()):
            op_sign = "|"
        case ast.BinOp(op=ast.BitXor()):
            op_sign = "^"
        case _:
            raise Exception(f"unsupported bin op type {op_type}")
    left = dump_expr(module.left)
    right = dump_expr(module.right)
    return f"({left} {op_sign} {right})"
```

Преимущества подхода:
* Шаблоны можно всячески усложнять, выбирая всё более специфичные случаи.
* Если ни один шаблон не подойдёт, выбрасывается пользовательское исключение с понятным описанием.
* Метод `type()` нигде явно не вызывается

Недостатки:
* Концепция явного выбора типа дочернего элемента осталась
* Пользовательские названия функций, заставляющие напрягать фантазию

### Использование `ast.NodeVisitor`

Как ни странно, модуль, описывающий абстрактное дерево в виде структуры, предоставляет также и методы для его обхода.
Этот метод называется `ast.NodeVisitor.visit()`

Как следует из названия, NodeVisitor реализует шаблон проектирования 
[Посетитель](https://refactoring.guru/ru/design-patterns/visitor),
позволяющий создавать новую внешнюю функциональность с минимальным изменением уже написанного кода.

Для написания своего посетителя необходимо объявить класс-наследник класса `ast.NodeVisitor`

```python
import ast

class DumpVisitor(ast.NodeVisitor):
    pass
```

Это наследование даёт новые возможности для обхода дерева:
* Метод `self.visit(node)` уже определён. Он выбирает и вызывает метод посещения каждого отдельного типа узла,
например, `self.visit_BinOp(node)`
* Для каждого типа узла из модуля `ast` определён метод обхода. Его необходимо лишь переопределить, а не писать заново.

С использованием `ast.NodeVisitor` код обхода бинарной операции станет таким:

```python
from ast import *

class DumpVisitor(NodeVisitor):
    ...
    def visit_BinOp(self, node: BinOp) -> str:
        return f"({self.visit(node.left)} {self.visit(node.op)} {self.visit(node.right)})"

    def visit_Add(self, node: Add) -> str:
        return "+"

    def visit_Sub(self, node: Sub) -> str:
        return "-"

    def visit_Div(self, node: Div) -> str:
        return "/"

    def visit_FloorDiv(self, node: FloorDiv) -> str:
        return "/"

    def visit_Mult(self, node: Mult) -> str:
        return "*"

    def visit_Mod(self, node: Mod) -> str:
        return "%"

    def visit_LShift(self, node: LShift) -> str:
        return "<<"

    def visit_RShift(self, node: RShift) -> str:
        return ">>"

    def visit_BitAnd(self, node: BitAnd) -> str:
        return "&"

    def visit_BitOr(self, node: BitOr) -> str:
        return "|"

    def visit_BitXor(self, node: BitXor) -> str:
        return "^"
    ...
```

Код остальных методов посетителя можно изучить в 
[репозитории](https://github.com/PenzaStreetGames/MetaStruct/blob/main/tree_to_code/dump_visitor.py).

Преимущества подхода:
* Выбор обработчиков узлов выполняется автоматически в методе `self.visit(node)`
* Названия функций их сигнатура уже определены, требуется лишь переопределение
* Используя один и тот же интерфейс класса `ast.NodeVisitor` можно писать множество посетителей одного дерева

Недостатки подхода:
* Шаблон проектирования "Посетитель" делает код более, как ни странно, шаблонным
* При обработке неизвестного типа узла посетителем возвращается `None`, что может сломать логику остальной программы.

> If no visitor function exists for a node (return value `None`) the `generic_visit` visitor is used instead.

Таким образом, после рассмотрения разных методов обхода дерева был сделан вывод, что эта задача в Питоне
довольно элегантно и объектно-ориентировано решена в модуле `ast`. При написании трансляторов для других
предметно-ориентированных языков следует организовать объектно-ориентированную модель абстрактного синтаксического 
дерева и выполнять его обход, используя шаблон проектирования "посетитель".


## Использование GCC для задачи JIT-компиляции

*GNU Compiler Collection* (сокращённо GCC) - набор свободно распространяемых компиляторов для множества языков, таких
как C, C++, Java, Go, Objective-C, Fortran, Ada, D

Разрабатывается и поддерживается группой программистов со всего мира и курируется Фондом Свободного Программного
Обеспечения. По количеству поддерживаемых платформ и архитектур процессоров является лидером среди компиляторов.

Распространяется по лицензии [GNU GPL 3](https://ru.wikipedia.org/wiki/GNU_General_Public_License#GPL_v3), что
одновременно является плюсом и минусом.

* С одной стороны, открытый исходный код даёт возможность пользователям искать узкие места программы и предлагать
  оптимизации, любой желающий может сделать свой продукт на основе gcc, не задумываясь над авторскими отчислениями (
  однако, авторов gcc всё равно придётся указать)
* С другой стороны, лицензия принуждает делать продукты использующие gcc под GNU GPL тоже открытыми. Для бизнеса это
  требование может быть критично, так как, открыв исходники, они теряют исключительное право знания алгоритма работы
  своих программ, и, возможно, вместе с этим часть выручки.

Именно по этой причине большие компании с большей охотой используют Clang вместе с LLVM под более проприетарной
лицензией
[Apache License 2.0](https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%86%D0%B5%D0%BD%D0%B7%D0%B8%D1%8F_Apache#Apache_License_2.0)

Опустив коммерческие подробности, стоит сказать, что для учебных и исследовательских проектов, подобных этому, нет
никакой разницы при выборе между Clang и GCC.

Забегая немного вперёд, отметим, что в нашем jit-компиляторе будет выполнять компиляцию файлов на языке C++ в
динамически подключаемую библиотеку (DLL - Dynamic Linked Library).

Первой стадией компиляции будет сборка объектных фалов из исходного текста программы.

```shell
g++ -O2 -c source.cpp -o object.o
```

Утилита `g++` используется для компиляции программ на языке C++ и входит в состав GCC. Не будем перечислять и описывать
[все возможные флаги](https://man7.org/linux/man-pages/man1/g++.1.html), а отметим только те, что используются:

* `-c` - отключает работу линковщика, компиляция останавливается на промежуточной стадии объектных файлов
* `source.cpp` - названия файла с исходниками, команда gcc разрешает перечисление нескольких таких файлов
* `-o filename` - название выходного файла
* `-O2` - уровень оптимизации кода, подробнее про низкоуровневые особенности оптимизации можно почитать
  [тут](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html). Так как в проекте будут компилироваться достаточно
  небольшие блоки кода, время компиляции не так важно, как скорость работы собранного модуля.

Вторым и последним шагом будет сборка динамической библиотеки из объектного файла. Это операция выполняется командой:

```shell
g++ -shared object.o -o lib.dll
```

Флаг `-shared` как раз отвечает за создание динамической библиотеки `.dll` либо `.so` в зависимости от платформы вместо
обычного бинарного файла по типу `.exe` или `.elf`

На этом участие компилятора GCC в данном проекте заканчивается. Следует отметить, что это единственная внешняя
зависимость этого проекта.

Замечание. Для особо ярых поклонников Clang и LLVM предусмотрена дружелюбность утилит командной строки и похожесть
интерфейса. Теоретически, даже на практике в рамках этой задачи, возможно заменить `g++ -O2` на `clang -O2` без
*явных внешних* изменений.

## Работа с DLL в Python

Динамически подключаемая библиотека (DDL) - программный модуль, состоящий из набора функций. Основное отличие от .EXE
файлов в том, что функции в DLL можно запускать по одной, в то время как в .EXE файлах все функции запускаются вместе.
Формат DLL присущ только ОС Windows, в Unix системах применяются файлы с расширением .so, что не меняет их роли.

В этом проекте файлы с расширением `.dll` получаются на выходе компиляции утилитой `g++` и должны подключаться к 
среде выполнения Питона для вызова функций.

По работе с DLL в языке Python есть хорошая [статья на Хабре](https://habr.com/ru/post/499152/). Опишем лишь 
особенности с DLL, напрямую связанные с проектом.

### Подключение

Для подключения динамической библиотеки используется пакет `ctypes`

```python
from ctypes import LibraryLoader, CDLL

dll = LibraryLoader(CDLL).LoadLibrary(dll_filename)
```

Функции лежат внутри объекта `dll`. Чтобы к ним обратиться, можно как `dll.func(arg, ...)`, 
либо как `dll["func"](arg, ...)` (для случая динамического выбора имени функции или имени, не являющегося валидным
названием Питона)

### Имена функций и `extern "C"`

С++ видоизменяет названия функций согласно их сигнатуре и аргументам. Например, функцию `int f(int x)` компилятор может
преобразовать в `_Z1fi`. Подробнее о соглашении именования функции при компиляции можно узнать, например, 
[здесь](https://en.wikipedia.org/wiki/Name_mangling)

После переименования к функциям уже нельзя обратиться по первоначальному названию.
Конечно, можно было бы написать свой алгоритм, который делает те же преобразования, что и компилятор. Но на самом деле,
существует более простое решение.

При добавлении к объявлению функции префикса `extend "C"` имена не будут кодироваться:

```cpp
extern "C" int sum(int x, int y) {
    int res = (x + y);
    return res;
}
```

Так происходит, потому что мы явно указываем, что имена функций должны кодироваться по соглашению языка C, 
то есть, никак.

### Сигнатуры функций

До этого момента подразумевалось, что вся задача транслятора - это преобразовать дерево в строку с текстом программы.
Однако, для корректного запуска функций из .dll необходимо явно указать, какие значения каких типов принимаются на вход
и какой тип возвращаемого значения. То есть, помимо итоговой строки нужно получить сигнатуры функций, которые 
обрабатываются в дереве.

Для этого в нескольких посетителях необходимо передать типы.
* В посетителе аргументов функции:
```python
def visit_arg(self, node: arg) -> Tuple[str, str]:
    return node.arg, self.visit(node.annotation)
```
* В посетителе функции:
```python
def visit_FunctionDef(self, node: FunctionDef) -> Tuple[str, dict]:
    ret_type = self.visit(node.returns)
    name = node.name
    args, args_signature = [], []
    for arg in node.args.args:
        arg, arg_type = self.visit(arg)
        args.append(f"{arg_type} {arg}")
        args_signature.append(ctype_convert(arg_type))
    args = ", ".join(args)
    res = f"extern \"C\" {ret_type} {name}({args}) {{\n"
    res += self.dump_body(node.body) + "}"
    signature = {
        "argtypes": args_signature,
        "restype": ctype_convert(ret_type)
    }
    return res, signature
```
* В посетителе модуля:
```python
def visit_Module(self, node: Module) -> Tuple[str, dict]:
    res, signatures = "", {}
    for elem in node.body:
        match elem:
            case FunctionDef(name=name):
                func_text, signature = self.visit(elem)
                res += func_text + "\n"
                signatures[name] = signature
    return res, signatures
```

Использующаяся функция `ctype_convert` преобразует строковое представление типа Питона
в соответствующий тип модуля ctypes.

```python
import ctypes

def ctype_convert(type_str: str):
    match type_str:
        case "int":
            return ctypes.c_int
        case "double":
            return ctypes.c_double
        case "bool":
            return ctypes.c_bool
        case _:
            raise Exception(f"unsupported type str {type_str}")
```

Расширение этой функции с добавлением поддержки новых типов не составит труда.

В результате на выходе транслятора помимо текста программы, будет словарь вот такого вида:
```python
{
  'sum': 
  {
    'argtypes': 
      [
        <class 'ctypes.c_long'>, 
        <class 'ctypes.c_long'>
      ], 
    'restype': <class 'ctypes.c_long'>
  }
}
```
Магическим образом `c_int` превратился в `c_long`. Впрочем, в модуле c_types даже есть комментарий на этом месте:
> if int and long have the same size, make c_int an alias for c_long

Примем за истину.

## Алгоритм JIT-компиляции программ на Python

Итак, описав большое количество "низкоуровневых" слабо связанных модулей системы, можно приступать к приятной сборке
конструктора.

### Процесс компиляции

На вход функции компиляции поступает объект функции, но для трансляции нужен именно её текст. Эта проблема решается
использованием функции `getsource` из модуля `inspect`
```python
source = inspect.getsource(func)
```

Далее из текста получается абстрактное дерево с помощью `ast.parse`
```python
ast_object = ast.parse(source)
```

Функция трансляции абстрактного дерева синтаксиса в текст программы на C++ также записывает её во временный файл.
Именно в ней запускается проход по дереву `DumpVisitor().visit(tree)`

```python
def dump_cpp_text(tree: ast.Module = None, filename: str = None) -> dict:
    text, signatures = DumpVisitor().visit(tree)
    with open(filename, "w", encoding="utf-8") as outfile:
        outfile.write(text)
    return signatures
```

Вызов утилиты `g++` происходит через интерфейс командной строки с использованием `subprocess.run()`
```python
cpp_filename = f"cache/{func.__name__}.cpp"
signatures = dump.dump_cpp_text(tree=ast_object, filename=cpp_filename)
o_filename = cpp_filename.replace(".cpp", ".o")
subprocess.run(["g++", "-O2", "-c", cpp_filename, "-o", o_filename])
dll_filename = o_filename.replace(".o", ".dll")
subprocess.run(["g++", "-shared", "-o", dll_filename, o_filename])
```

И наконец, созданная библиотека dll загружается в объект Питона.

```python
dll = LibraryLoader(ctypes.CDLL).LoadLibrary(dll_filename)
```

Весь код функции `compile_dll` представлен ниже:

```python
def compile_dll(func: Callable) -> Tuple[ctypes.CDLL, dict]:
    source = inspect.getsource(func)
    ast_object = ast.parse(source)
    
    if not os.path.exists("cache"):
        os.makedirs("cache")
        
    cpp_filename = f"cache/{func.__name__}.cpp"
    signatures = dump.dump_cpp_text(tree=ast_object, filename=cpp_filename)
    
    o_filename = cpp_filename.replace(".cpp", ".o")
    subprocess.run(["g++", "-O2", "-c", cpp_filename, "-o", o_filename])
    
    dll_filename = o_filename.replace(".o", ".dll")
    subprocess.run(["g++", "-shared", "-o", dll_filename, o_filename])
    os.remove(o_filename)
    
    dll = LibraryLoader(ctypes.CDLL).LoadLibrary(dll_filename)
    return dll, signatures
```

Также в процессе JIT-компиляции происходит кеширование и удаление некоторых промежуточных файлов.

### Аннотация `@jit`

Используя "синтаксический сахар" Питона и его возможности функционального программирования было бы неплохо написать
аннотацию вида:

```python
@jit
def sum(x: int, y: int) -> int:
    res: int = x + y
    return res
```

Которая компилирует помеченную функцию и возвращает нам скомпилированный вариант. "Под капотом" будет происходить
вызов этой функции из .dll файла.

Алгоритм декоратора будет выглядеть примерно так:

```python
def jit(func: Callable) -> Callable:
    exec_module, signatures = compile_dll(func)
    name = func.__name__
    jit_func = exec_module[name]
    jit_func.argtypes = signatures[name]["argtypes"]
    jit_func.restype = signatures[name]["restype"]
    return jit_func
```

Стоит отметить, что именно такой интерфейс использует Numba (аннотация `@numba.jit`)

## Оценка скорости выполнения программ с JIT-компиляцией и без

Созданный алгоритм JIT-компиляции был протестирован на нескольких простых алгоритмических задачах:

* Сумма двух чисел
* Хеш-функция для целых чисел
* N-ое простое число
* Вычисление экспоненты через ряд Тейлора
* Числа Фибоначчи

С расчётами и графиками можно подробнее ознакомиться в 
[Jupyter-блокноте](https://github.com/PenzaStreetGames/MetaStruct/blob/main/performance.ipynb)

Сразу стоит отметить, что реализация алгоритмов не "изящна" (в том же подсчёте делителей для простых чисел можно было бы 
останавливаться на $\sqrt{n}$, а не $n - 1$). Это сделано в какой-то мере преднамеренно, чтобы показать эффективность
алгоритмов JIT-компиляции на алгоритмах с большой алгоритмической сложностью.

Для оценки времени выполнения использованы функции `timeit()` и `repeat()` модуля `timeit`.
Для отрисовки графиков использовался модуль `matplotlib`, для вычисления некоторых статистических 
характеристик - `numpy` 

В примерах будут сравниваться три реализации функций:
* Оптимизированных аннотацией `@jit`
* Оптимизированных аннотацией `@numba.jit`
* Оптимизированных ничем (просто функция питона)

### Сумма двух чисел

На примере простой функции суммы двух целых чисел оценим следующие величины:
* Скорость компиляции
* Скорость первого запуска
* Скорость многократного прогона

Оптимизируемая функция:
```python
def py_sum(x: int, y: int) -> int:
    res: int = x + y
    return res
```

Оценим время компиляции функции:

```python
from timeit import repeat

jit_time = repeat(lambda: jit(py_sum), repeat=10, number=1)
numba_jit_time = repeat(lambda: numba.jit(py_sum), repeat=10, number=1)
```

График представлен ниже:

![Скорость компиляции](plots/compile_sum.png)

Из графика можно сделать следующие выводы:
* Компиляция своей реализацией выполняется в 2,5 раза быстрее
* Numba не проводит повторную компиляцию модуля, за счёт чего экономит время. (В теории, можно добавить проверку 
на хеш объекта функции, чтобы возвращать результаты уже скомпилированных блоков кода. Однако, многократный вызов
функции компиляции для одного блока кода не логичен, поэтому эта оптимизация не была произведена в этом проекте)

Оценим время нескольких вызовов функции:

```python
python_exec_time = repeat(lambda: py_sum(2, 2), repeat=10, number=1)
jit_exec_time = repeat(lambda: jit_sum(2, 2), repeat=10, number=1)
numba_exec_time = repeat(lambda: numba_sum(2, 2), repeat=10, number=1)
```

Результат на графике ниже:

![Время выполнения одного вызова](plots/exec_sum_once.png)

Выводы по графику:
* У функции с аннотацией `@numba.jit` очень большое время первого запуска, практически сравнимое со скоростью компиляции.
Можно предположить, что при первом запуске выполняются некоторые отложенные стадии компиляции.

Оценим время многократного вызова функции сложения:

```python
python_exec_time = repeat(lambda: py_sum(2, 2), repeat=10, number=1000000)
jit_exec_time = repeat(lambda: jit_sum(2, 2), repeat=10, number=1000000)
numba_exec_time = repeat(lambda: numba_sum(2, 2), repeat=10, number=1000000)
```

Результат на графике ниже:

![Скорость многократного выполнения, функция суммы](plots/exec_sum.png)

Выводы по графику:
* На простой задаче с линейной сложностью питон выполняется быстрее JIT-компилированных версий. Это можно
объяснить накладными расходами на вызов функции из dll
* И даже на такой простой задаче, Numba проигрывает всего в 1,5 раза, в то время как наш компилятор в 4,5 раза

### Хеш-функция для целых чисел

Обычно, для чисел из небольшого диапазона в качестве хеша используют их самих. Однако на просторах Интернета
была найдена следующая 
[хеш-функция](https://qastack.ru/programming/664014/what-integer-hash-function-are-good-that-accepts-an-integer-hash-key):

```python
def py_hash(x: int) -> int:
    x = ((x >> 16) ^ x) * 0x45d9f3b
    x = ((x >> 16) ^ x) * 0x45d9f3b
    x = (x >> 16) ^ x
    return x
```

Автором утверждается, что это значение параметра позволяет достичь наибольшей "случайности" бит внутри числа. По
крайней мере в локальном минимуме хеш-функций такого вида.

Выполнив тестовые прогоны для этой функции, аналогичные прогонам функции суммы, получим следующий график:

```python
python_exec_time = repeat(lambda: py_hash(42), repeat=10, number=1000000)
jit_exec_time = repeat(lambda: jit_hash(42), repeat=10, number=1000000)
numba_exec_time = repeat(lambda: numba_hash(42), repeat=10, number=1000000)
```

![Скорость многократного выполнения, хеш-функция](plots/exec_hash.png)

Выводы по графику:
* Не смотря на простоту функции, компиляция аннотацией `@jit` дала незначительный прирост к эффективности
* Не совсем понятно, откуда у Numba взялась такая оптимизация на битовых операциях. Скорее всего, спонсорство
NVIDIA, Intel и AMD сыграло свою роль.

### N-ое простое число

Методом грубой силы была создана эта реализация алгоритма, выдающего n-ое простое число:

```python
def py_n_primary(n: int) -> int:
    count: int = 0
    number: int = 2
    while count < n:
        i: int = 2
        is_prime: bool = True
        while i < number:
            if number % i == 0:
                is_prime = False
                break
            i += 1
        if is_prime:
            count += 1
        number += 1
    return number - 1
```

Запустив тестовые прогоны для разных значений N получим такой график:

![Скорость многократного выполнения, простые числа (3)](plots/exec_prim_3.png)

Выводы по графику:
* Невооружённым глазом видно, что питон без оптимизации начал работать неприлично медленно
* Разница между двумя оптимизациями невооружённым глазом на это графике не видна, поэтому построим ещё один, без 
`python_time`

![Скорость многократного выполнения, простые числа (2)](plots/exec_prim_2.png)

Выводы по графику:
* Аномалия первого запуска Numba была обсуждена ранее
* Оба графика наложились друг на друга, не показывая явного преимущества той или иной оптимизации

### Вычисление экспоненты через ряд Тейлора

Для людей, когда-либо изучавших математический анализ и теорию рядов должна быть знакома такая формула:

$$e^x = \displaystyle\sum_{n=0}^\infty \frac{x^n}{n!}$$

Это формула разложения экспоненты в ряд Тейлора в окрестности точки. Благо, этот ряд сходится везде на оси X.

Стоит отметить, что математические вычисления - это как раз та область, где оптимизация вычислений играет значительную 
роль. Именно поэтому был рассмотрен такой оторванный от жизни пример.

Алгоритм нахождения значения экспоненты в точке:

```python
def py_exp(x: float) -> float:
    res: float = 0
    threshold: float = 1e-30
    delta: float = 1
    elements: int = 0
    while delta > threshold:
        elements = elements + 1
        delta = delta * x / elements
    while elements >= 0:
        res += delta
        delta = delta * elements / x
        elements -= 1
    return res
```

Алгоритм прекращается, когда разница между дельтами двух итераций становится меньше порога, либо превращается в 
машинный ноль. Суммирование происходит от меньших членов к большим для меньших потерь точности.

Взглянув на график ниже, можно сказать, что питон справился с этой задачей неважно:

![Скорость многократного выполнения, экспонента (3)](plots/exec_exp_3.png)

Поэтому рассмотрим JIT-реализации на отдельном графике:

![Скорость многократного выполнения, экспонента (2)](plots/exec_prim_2.png)

Опять почти полное совпадение и экспоненциальный рост времени вычислений. И опять нет однозначного лидера.

### Числа Фибоначчи

Несмотря на то, что аннотация позволяет компилировать функции по одной, в ней всё ещё можно использовать рекурсию.

Напишем функцию для n-го члена классического ряда Фибоначчи:

```python
def py_fib(n: int) -> int:
    if n < 2:
        return 1
    return py_fib(n - 1) + py_fib(n - 2)

@jit
def jit_fib(n: int) -> int:
    if n < 2:
        return 1
    return jit_fib(n - 1) + jit_fib(n - 2)

@numba.jit(nopython=True)
def numba_fib(n: int) -> int:
    if n < 2:
        return 1
    return numba_fib(n - 1) + numba_fib(n - 2)
```

Из-за того, что рекурсия плохо работает внутри декораторов, аннотации были прописаны отдельно для каждой реализации 
(в предыдущих примерах реализовывалась только одна функция, на которую добавлялись аннотации)

Взяв адекватное для рекурсивного решения без памяти значение аргумента n, получим такой график:

![Скорость выполнения, числа Фибоначчи (3)](plots/exec_fib_3.png)

С питоном без оптимизации всё понятно, но что происходит между оптимизациями:

![Скорость выполнения, числа Фибоначчи (2)](plots/exec_fib_2.png)

Внезапно, реализованная в проекте компиляция начала работать в 4 раза быстрее, чем Numba.
Получается, что с задачами разветлённой рекурсии JIT-компилятор неплохо справляется.

Это одно из самых интересных мест всего исследования, которе можно было бы продолжить.

## Применимость JIT-компиляции в Python

Рассмотрев примеры задач, показанных выше, можно сформировать список классов задач, где JIT-компиляция окупает своё 
применение:
* Задачи с большой алгоритмической сложностью. В плане итераций и переборов в питоне всё не очень хорошо. Поэтому 
ускорение вычислений может окупить расходы на компиляцию.
* Задачи с рекурсией. Использование стека вызовов C++ позволяет ускорить выполнение рекурсивных алгоритмов.
* Задачи с ограничением типов. Когда все числа укладываются в диапазон int32, избыточно использовать длинную арифметику 
питона (но тут есть ниша numpy, в которую не входят только сложные алгоритмы)

Случаи, когда применима *именно* JIT-компиляция, а не обычная:
* Часто решаемые задачи в интерпретируемых языках программирования, которые не были добавлены в виде модуля другого языка.
* Сборка программ на лету. Например, регулярные выражения.
* Компромисс между временем запуска и временем исполнения.

JIT-компиляция не применима, когда:
* Задача решается за линейное время. Расходы на вызов функции из динамической библиотеки обработка результата могут 
аннулировать быстроту вычислений.
* Задача вызывается небольшое количество раз. В этом случае время на компиляцию не окупается последующими запусками
модуля. Также, общий вклад в ускорение становится не таким уж очевидным.

## Выводы

Разнообразие методов исполнения программ указывает на то, что среди них нет единственного и лучшего. Использование
JIT-компиляции оправдано только тогда, когда оно оправдано.

На примере этого довольно игрушечного проекта были показаны основные этапы и затруднения создания JIT-компилятора.
Если речь идёт не о Питоне, а о каком-нибудь предметно-ориентированном языке, то написание такого компилятора может быть
жизненно необходимым, но осложнённым отсутствием кодовой инфраструктуры, наподобие модуля AST.

На различных задачах было показано, что проблема производительности Питона решается, в частности, JIT-компиляцией,
как самым не накладным, в смысле переписывания кода, способом. Было показано, что ответственность за применение 
алгоритмов оптимизации несёт только разработчик. Также было выявлено несколько аномалий в работе Numba, над которыми
предлагается поразмышлять читателю.

Помимо примитивных типов, на уровне C++ могут поддерживаться более сложные структуры, даже объекты Питона. Тогда
JIT-компиляция приобретает всё большую пользу (что и используется в Numba). Но об этом как-нибудь в другой раз.

## Список литературы и ссылки

О проекте GCC:

https://ru.wikipedia.org/wiki/GNU_Compiler_Collection

О лицензии GNU GPL:

https://ru.wikipedia.org/wiki/GNU_General_Public_License#GPL_v3

Флаги оптимизации GCC:

https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html

Сравнение скорости Питона и C++:

https://towardsdatascience.com/how-fast-is-c-compared-to-python-978f18f474c7

Руководство по g++:

https://man7.org/linux/man-pages/man1/g++.1.html

О лицензии Apache License v 2.0:

https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%86%D0%B5%D0%BD%D0%B7%D0%B8%D1%8F_Apache#Apache_License_2.0

О проекте LLVM:

https://habr.com/ru/company/huawei/blog/511854/

О компиляции Python:

https://habr.com/ru/company/numdes/blog/581374/

О работе с DLL в Python:

https://habr.com/ru/post/499152/

Описание DLL:

https://ru.wikipedia.org/wiki/Динамически_подключаемая_библиотека

Описание PyPy:

https://ru.wikipedia.org/wiki/PyPy

Описание Numba:

https://en.wikipedia.org/wiki/Numba

Сайт проекта Numba:

https://numba.pydata.org/

Сайт проекта MyPy:

http://www.mypy-lang.org/

Работа с AST:

https://pybit.es/articles/ast-intro/

Шаблон проектирования "Посетитель":

https://refactoring.guru/ru/design-patterns/visitor

Конструкция match/case:

https://docs-python.ru/tutorial/tsikly-upravlenie-vetvleniem-python/konstruktsija-match-case/

Аннотации типов в Питоне:

https://docs.python.org/3/library/typing.html

https://habr.com/ru/company/lamoda/blog/432656/


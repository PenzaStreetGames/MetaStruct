# Постановка задачи

## Дано:

Класс данных (например Сотрудник), имеющий поля разного типа.

Класс находится на сервере, написанном на языке Джава (к примеру, фреймворк Spring)

Примерное наполнение информационного класса:

```java
public class Employee {
    
    private int id;
    public String name;
    public int age;
    public String phone;
    public String address;
    
}
```

Особенности класса и его полей могут описываться аннотациями.

Особенности класса и его полей могут также описываться конфигурационным файлом (`.json` или `.yml`) 

Поля могут иметь логические ограничения, например, поле `age` должно содержать значение больше 18. Или в поле `phone`
должна лежать строка формата `+7(XXX)-XXX-XX-XX`

## Требуется сделать:

- Дублирующий информационный класс на JavaScript
- Генерация скелета "карточки" в коде HTML
- Разновидности карточки сущности в зависимости от метода обработки (модель CRUD)
- Обработка набора карточек с помощью JavaScript скрипта
- Валидация полей карточек при попытке отправки запроса на сервер
- Исчерпывающий набор аннотаций для класса Java
  - Либо конфигурационный файл для связи сущностей и их отображения на клиенте
- Систему генерации JavaScript кода

# Возможное решение
## Дублирующий информационный класс на JavaScript

Самое элементарное, что можно сгенерировать на основе имеющегося класса данных на сервере - это класс данных на клиенте.
Допустим, он просто дублирует поля:

```javascript
function EmployeeUser(/* аргументы? */) {
    this.name = name;
    this.age = age;
    this.phone = phone;
    this.address = address;
    
    return this;
}
```

Будем называть _**карточкой**_ (или _**интерфейсом**_) визуальное представление класса на клиенте, набор отображаемых
полей класса с возможностью их редактирования.

У одного класса данных может быть несколько карточек, каждая карточка имеет разный набор отображаемых полей. Допустим,
есть две карточки одного класса данных:

| Карточка | id | name | age | phone | address |
|----------|----|------|-----|-------|---------|
| user     | -  |  +   |  +  |   +   |    +    |
| admin    | +  |  +   |  +  |   +   |    +    |
|          |    |      |     |       |         |

В примере интерфейсы-карточки `user` и `admin` отличаются только отображением поля `id`, но возможны и более
значительные отличия отображения от интерфейса к интерфейсу.

Но каждая такая карточка может содержать ссылку на HTML-теги относящиеся к отображению карточки. С помощью этих ссылок
можно изменять и считывать значение внутри этих полей.

```javascript

function EmployeeUser(/* аргументы? */) {
    this.name = name;
    this.age = age;
    this.phone = phone;
    this.address = address;

    this.objectId = 1 /* 1, 2, 3, ... */
    this.name_field = document.querySelector("#employee_user_name_{objectId}");
    this.name_field.innerText = name;
    this.age_field = document.querySelector("#employee_user_name_{objectId}");
    this.age_field.innerText = age;
    /*
    this.phone_field = ...
    this.address_field = ...
    */
  
    return this;
}
```

Поле `EmployeeUser.objectId` не связано с серверным `Employee.id`. `EmployeeUser.objectId` используется только для
контроля нескольких карточек одного класса на одной странице. При перезагрузке страницы номера могут перераспределяться.

Получается динамическая сущность, которая нуждается в HTML-структуре и JavaScript цикле обработки.

## Генерация скелета "карточки" в коде HTML

Стоит отметить, что взять на себя отображение карточки целиком по классу с сервера невозможно, потому что от клиента к
клиенту меняются стили (CSS и прочие). Часть отображения, например заголовки и сопровождающий текст, можно оформить и с
помощью аннотаций.

В зависимости от того, показываются данные или изменяются, возможны разные варианты карточек. Карточка для чтения может
выглядеть так:

```html
<div id="employee_user_card_{objectId}">
    <h2 id="employee_user_name_{objectId}"></h2>
    <div>
        <p id="employee_user_age_label_{objectId}">Возраст</p>
        <p id="employee_user_age_{objectId}"></p>
    </div>
    <div>
        <p id="employee_user_phone_label_{objectId}">Телефон</p>
        <p id="employee_user_phone_{objectId}"></p>
    </div>
    <div>
        <p id="employee_user_address_{objectId}"></p>
    </div>
</div>
```

Настройка подписи к полю (поля `age` и `phone`) а также тег, в котором будет отображаться информация 
(`<h2>`, `<p>` и другие) настраивается либо через конфигурационный файл, либо через аннотации.

Карточка для создания пользователя может выглядеть немного иначе:

```html
<div id="employee_user_card_{objectId}">
    <input id="employee_user_name_{objectId}">
    <div>
        <p id="employee_user_age_label_{objectId}">Возраст</p>
        <input id="employee_user_age_{objectId}">
    </div>
    <div>
        <p id="employee_user_phone_label_{objectId}">Телефон</p>
        <input id="employee_user_phone_{objectId}">
    </div>
    <div>
        <input id="employee_user_address_{objectId}">
    </div>
    <div>
        <button onclick="handleCreateQuery('employee_user', objectId)">
            Отправить
        </button>
    </div>
</div>
```

Полученный шаблон для карточки можно генерировать с помощью JavaScript на лету, а можно вставлять готовым
куском в нужное место html-страницы.

В зависимости от метода обработки карточки (чтение, создание, редактирование) имеет смысл использовать одиночные 
карточки и их коллекции. Например, для вывода списка существующих сотрудников может понадобиться список из карточек для
чтения, а для создания нового сотрудника, одиночная карточка создания.

## Разновидности карточки сущности в зависимости от метода обработки (модель CRUD)

В связи с разным скелетом карточек для разных видов запросов (создание, чтение, редактирование и поиск)
Может понадобиться дополнительное разделение карточек по видам запросов, например `EmployeeUserCreate`
`EmployeeUserRead` `EmployeeUserUpdate` `EmployeeUserDelete`

Карточки для чтения содержат поля, но не позволяют их изменять.

Карточки для создания не содержат информации изначально (заменители текста полей можно 
прописать и сгенерировать), но содержат поля ввода и кнопку подтверждения запроса на добавление

Карточки для редактирования являются гибридом двух предыдущих видов

Карточки для удаления содержат ключевые поля для поиска объекта и кнопку подтверждения запроса на 
удаление

Функционал этих карточек, вероятно, может комбинироваться на одной карточке (например, на карточке в панели
администратора сервера)

## Обработка набора карточек с помощью JavaScript скрипта

Над всеми карточками и видами карточек на странице существует обработчик - скрипт-цикл проверки. Его функции:

- Генерация карточек при необходимости
- Удаление карточек при необходимости
- Передача данных карточкам для отображения
- Получение данных из карточек при попытке отправить форму карточки
- Валидация данных из карточек при попытке отправить форму карточки
- Обработка классов-сущностей
- Инициация запросов на сервер

Будем называть _**точкой монтирования**_ одной или набора карточек место в html-документе, куда будут помещаться карточки
этого типа (как предусмотреть несколько коллекций карточек одного типа на странице - открытый вопрос)

Допустим, функционал скрипта-обработки записан внутри класса `OrmHandler` (насколько термин ORM применим к этой модели -
спорный вопрос)

```javascript
function OrmHandler() {
    
    /* точки монтрирования коллекций карточек */
  
    this.mountPoints = {
        "employeeUserRead": document.querySelector("#mountPointEmployeeUserRead")
        /* некоторое количество записей вида тип карточки - точка монтирования */
    };
    
    /* коллекции карточек по видам */
    
    this.employeeUserReadCards = {};
    this.employeeUserCreateCards = {
        "employeeId": "employeeUserCreateCardId"
        /* некоторое количество записей вида id сущности с сервера - id карточки */
    };
    this.employeeUserUpdateCards = {};
    this.employeeUserDeleteCards = {};
    
    /* для каждого вида карточки объявляется своя коллекция*/
    
    /* метод обновления карточек (создания, удаления, изменения) */
    
    this.setEmployeeUserReadCards = function(objects) {/*...*/};
    
    /* для каждого вида карточки объявляется функция обновления состояния коллекции */
  
    /* методы обработки запросов на изменение карточек */
  
    this.handleCreateQuery = function(objectType, objectId) {/*...*/};
    this.handleUpdateQuery = function(objectType, objectId) {/*...*/};
    this.handleDeleteQuery = function(objectType, objectId) {/*...*/};
    
    return this;
}
```

### Генерация и удаление карточек

Скрипт-обработки общается с сервером асинхронными запросами, устанавливая, какие карточки необходимо добавить,
какие удалить, а какие оставить на месте. Между данными объектами класса `Employee` и `EmployeeUser` происходит
сопоставление, которое хранится в словаре ключ-значение.

В коде html необходимо задать точку монтирования с помощью id-элемента, например, вот так:

```html
<html>
<head>
  <!-- Заголовок -->
</head>
<body>
  <!-- Тело -->
  <div id="mountPointEmployeeUserRead">
    
  </div>
  <!-- Тело -->
</body>
</html>
```

При таком варианте монтирования все карточки типа `EmployeeUserRead` будут попадать в указанный тег `<div>`

### Передача данных карточкам для отображения

Происходит с помощью манипуляций над объектом класса EmployeeUser через методы-сеттеры, выглядящие следующим образом:

```javascript
function EmployeeUser() {
    /*...*/
    this.setName = function (name) {
        this.name = name;
        this.name_field.innerText = name;
    }
    /*...*/
}
```

### Получение данных из карточек при попытке отправить форму карточки

Происходит с помощью вызова функции `handle[Create,Update,Delete]Query('тип сущности', objectId)` 
(во избежание перегрузок пространства имён, можно положить функции обработки запросов внутрь объекта класса `OrmHanler`)

По пришедшей информации находится необходимый объект, так как тип сущности конкретно задаёт коллекцию объектов,
а id задаёт нужный объект. 

Данные из формы получены.

## Валидация полей карточек при попытке отправки запроса на сервер

Ограничения на данные поступают с сервера. Простые типы ограничений, по типу "больше нуля" и "непустое поле" можно задать
с помощью аннотаций к полям класса, например `@Positive` и `@NotEmpty`. Сложные ограничения по типу "число больше 18" или
"строка содержит валидный номер телефона" нельзя задать таким образом. Для этого можно воспользоваться синтаксическим
преобразователем Java->JavaScript.

Разберём пример с совершеннолетним сотрудником. Допустим, этот кусочек логики модели прописан в виде функции 
`checkAge` которая лежит внутри информационного класса `Employee` на сервере, либо косвенно относится к нему.

```java 
public class Employee {
    /*...*/
    
    @Check(this.age)
    public boolean checkAge() {
        return this.age >= 18;
    }
    
    /*...*/
}
```

Стоит заметить, что все функции валидации должны иметь схожую сигнатуру:

```java 
boolean check() {
    /*...*/
}
```

С помощью ручной генерации или преобразованием из одного ЯП в другой можно получить вот такую функцию на JavaScript:

```javascript
function checkAge() {
    return this.age >= 18;
}
```

Для обработки неправильно заполненных полей, эта функция должна откуда-то вызываться. Учитывая, что таких проверок и 
у одной сущности может быть много, неплохо было бы хранить список этих функций внутри класса, чтобы иметь возможность
проверить их все с помощью одного прохода цикла, например в поле `constraints` класса `EmployeeUser`.

```javascript
function EmployeeUser () {
    /*...*/
    this.constraints = [
        checkAge,
        checkPhone
        /* некоторое количество функций проверок */
    ];
    /*...*/
}
```

Тогда при обработке запросов `handle[Create,Update,Delete]Query('тип сущности', objectId)` перед возвратом класса 
сущности (или сериализованного json-объекта) необходимо выполнить проверки из списка, хранящегося внутри самого объекта:

```javascript
function handleCreateQuery(objectType, objectId) {
    /* Поиск объекта */
    let card = this[objectType + "Cards"][objectId];
    /* Валидация */
    for (var i = 0; i < card.constraints.length; i++) {
        if (!card.constraints[i]()) {
            ErrorHandler.sendError(/*...*/);
            return;
        }
    }
    HTTPQueryHandler.createQuery("create", objectType, objectId, card);
}
```

В примере выше использованы абстрактные сущности `HTTPQueryHandler` и `ErrorHandler`. В зависимости от того, как прошла 
валидация формы, либо создаётся ошибка (текст ошибки можно прописать в конфигурационном файле или аннотации к проверке),
либо формируется запрос на сервер.

Проблема в том, что это могут быть совершенно разные обработчики, зависящие от конкретного экземпляра клиента, прочих 
фреймворков, библиотек и кода, которые используются на клиенте. Сгенерировать такой код автоматически можно, но лучше 
будет оставить выбор фронт-энд разработчику, как следует обработать результаты валидации.

## Исчерпывающий набор аннотаций для класса Java

Идеи аннотаций в коде и конфигурационных файлов являются конкурирующими, но первая лучше подходит, когда нужно описать
небольшое число параметров (иначе читаемость кода теряется), а второй лучше подходит для описания сложных систем, чтение
которых без кода может быть даже проще, чем с кодом. Хотя, возможен и комбинированный метод.

Поэтому, раздел о конфигурационном файле будет прописан подробнее.

## Конфигурационный файл для связи сущностей и их отображения на клиенте

Для описания файла конфигураций можно выбрать любой язык разметки, но предпочтение стоит отдать более читаемым и лёгким,
например, `.json` или `.yml`

Конфигурационный файл должен содержать в себе список представлений информационных классов. Представления должны ссылаться
на класс данных, описывать поля, которые будут отображаться, связывать функции проверки с полями.

Конфигурационный файл обладает следующей структурой:

- Классы данных
  - Поля
    - Типы, ограничения, подписи
  - Интерфейсы
    - Типы карточек
      - Поля
        - Свойства, теги, заменяющий текст

Приведём пример такого файла конфигураций:

```yaml
"Employee":
  
  "source": "src/org/main/Employee.java"
  
  "fields":
    "id":
      "type": "int"
      "label": "id" 
    "name":
      "type": "string"
      "label": "Имя"
    "age":
      "type": "int"
      "label": "Возраст"
      "constraints":
        "notEmpty": null
        "checkAge": 
         "fail": "Возраст сотрудника должен быть больше 18 лет" 
    "phone":
      "type": "string"
      "label": "Номер телефона"
      "constraints":
        "notEmpty":
          "fail": "Поле phone пустое"
        "checkPhone": null
    "address":
      "type": "string"
      "label": "Домашний адрес"
  
  "interfaces":
    "user":
      "read":
        "label":
          "tag": "h2"
          "text": "Сотрудник"
        "fields":
          "name":
            "tag": "h3"
            "label": "Имя"
          "age":
            "tag": "p"
          "phone":
            "tag": "p"
          "address":
            "tag": "p"
      "create":
        "label":
          "tag": "h2"
          "text": "Добавление сотрудника"
        "fields":
          "name":
            "tag": "input"
            "attributes":
              "placeholder": "Введите имя"
          "age":
            "tag": "input"
            "attributes":
              "placeholder": "Введите возраст"
          "phone":
            "tag": "input"
            "attributes":
              "placeholder": "Введите телефон"
          "address":
            "tag": "input"
            "attributes":
              "placeholder": "Введите адрес"
    "admin":
      "update":
        "fields":
          "name":
            "tag": "input"
            "outerHTML": "td"
          "age":
            "tag": "input"
            "outerHTML": "td"
          "phone":
            "tag": "input"
            "outerHTML": "td"
          "address":
            "tag": "input"
            "outerHTML": "td"
```

По имеющемуся файлу конфигураций можно производить автогенерацию клиентов.

## Система сборки

Вершиной системы должен быть генератор кода клиента. Язык его написания может быть любой, но для удобства проектирования 
выберем `Python`.

### Входные данные

Папка проекта с классами Java и конфигурационными файлами

### Выходные данные 

Директория или архив с классами на языке JavaScript - клиентские классы и функции, сгенерированные по данным сервера

### Описание

Генерация - кода, весьма нетривиальная задача. Но по сути, по одному только классу данных можно сгенерировать его 
представление в браузере клиента, пусть и не очень настраиваемое. Весь процесс генерации не нуждается в средствах
перевода с одного ЯП на другой, кроме момента с валидацией полей. Понадобится переводчик с Java на JavaScript.

Несмотря на большой объём сгенерированного кода, его всё равно придётся встраивать вручную, так как для других функций
клиента существуют известные крупные фреймворки и библиотеки, решающие свою задачу максимально эффективно и хорошо. Вот
некоторые моменты, которые необходимо стыковать с остальным кодом клиента:

- Обработчик карточек нуждается во входных данных в виде списка сущностей, полученных из get-запроса к серверу
- Ошибки, возникающие при валидации, необходимо передать какому-либо обработчику на клиенте (пускай это будет даже 
  генератор всплывающих окон)
- Результат, полученный при успешной валидации необходимо передать API-части клиента для отправки
- Коллекции карточек нуждаются в явном указании места монтирования на шаблоне страницы

Возможно, какие-то важные моменты были упущены.

# Затруднения и вопросы

## Теоретические

- Насколько этот путь решения проблемы вообще правильный? (:D)
- Корректно ли называть эту систему ORM? Этот термин занят связи БД с сервером, но по сути этот инструмент тоже будет
  создавать представление, только в связи клиент-сервер
- Имеет ли значение валидация полей без всей созданной вокруг них оболочки?
- Стоит ли вкладывать информационную сущность JavaScript класса внутрь класса с полями? (разделение данных и представления)
- Что следовало бы возвращать после успешной валидации формы: сериализованный объект, класс данных или класс карточки?

## Практические

- Где взять преобразователь кода из Java в JavaScript?
- Есть ли библиотека для работы с YAML в Питоне?
- Возможна ли интеграция со Swagger для замыкания цепочки автоматического общения клиента и сервера?
- Плохой уровень знания JavaScript и других аспектов клиент-серверной разработки
